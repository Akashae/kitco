
obj/gamebuino_boot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007f6  00007800  00007800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .jumps        00000004  00007ffa  00007ffa  0000088a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .version      00000002  00007ffe  00007ffe  0000088e  2**0
                  CONTENTS, READONLY
  3 .bss          000002a0  00800100  00800100  0000088e  2**0
                  ALLOC
  4 .debug_aranges 00000068  00000000  00000000  00000890  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000118  00000000  00000000  000008f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e06  00000000  00000000  00000a10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005ac  00000000  00000000  00001816  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b42  00000000  00000000  00001dc2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000170  00000000  00000000  00002904  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000574  00000000  00000000  00002a74  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000075d  00000000  00000000  00002fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  00003745  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <main>:

}


/* main program starts here */
int main(void) {
    7800:	11 24       	eor	r1, r1
    
  // Adaboot no-wait mod, part 1
  // I split this up to use the same functionality to prevent
  // loader app being reflashed unnecessarily
  // Jonne Valola 2014
  ch = MCUSR;
    7802:	04 b7       	in	r16, 0x34	; 52
  MCUSR = 0;
    7804:	14 be       	out	0x34, r1	; 52

//#if 0
  // if the down button is currently pressed then try to run the loader app
  DDRD &= ~(1 << PD7);
    7806:	57 98       	cbi	0x0a, 7	; 10
  PORTD |= (1 << PD7);
    7808:	5f 9a       	sbi	0x0b, 7	; 11
  /* This is original Gamebuino code
  if (!(PINC & (1<<PC3))) 
  	  load_loader(); */ 
  if (!(PIND & (1<<PD7)) && !(ch & _BV(EXTRF)) ) {
    780a:	4f 99       	sbic	0x09, 7	; 9
    780c:	14 c0       	rjmp	.+40     	; 0x7836 <main+0x36>
    780e:	01 fd       	sbrc	r16, 1
    7810:	12 c0       	rjmp	.+36     	; 0x7836 <main+0x36>
	  // Use MCUSR to determine whether its a hard or soft boot.
	  // Only boot to loader if it is a hard boot - JV2014
	  watchdogConfig(WATCHDOG_OFF); // turn off watchdog so we do not reset
    7812:	80 e0       	ldi	r24, 0x00	; 0
    7814:	ce d0       	rcall	.+412    	; 0x79b2 <watchdogConfig>
	  mydelay(25000); // for debouncing
    7816:	68 ea       	ldi	r22, 0xA8	; 168
    7818:	71 e6       	ldi	r23, 0x61	; 97
    781a:	80 e0       	ldi	r24, 0x00	; 0
    781c:	90 e0       	ldi	r25, 0x00	; 0
    781e:	88 d0       	rcall	.+272    	; 0x7930 <mydelay>
	   if (!(PIND & (1<<PD7))) {
    7820:	4f 99       	sbic	0x09, 7	; 9
    7822:	07 c0       	rjmp	.+14     	; 0x7832 <main+0x32>
		   mydelay(25000); // for debouncing
    7824:	68 ea       	ldi	r22, 0xA8	; 168
    7826:	71 e6       	ldi	r23, 0x61	; 97
    7828:	80 e0       	ldi	r24, 0x00	; 0
    782a:	90 e0       	ldi	r25, 0x00	; 0
    782c:	81 d0       	rcall	.+258    	; 0x7930 <mydelay>
           if (!(PIND & (1<<PD7)))     load_loader();//greenLedON();
    782e:	4f 9b       	sbis	0x09, 7	; 9
    7830:	ef d0       	rcall	.+478    	; 0x7a10 <load_loader>
//load_loader(); // ok, now sure it is wanted
	  } 
	  // perform normal boot otherwise
	  watchdogConfig(WATCHDOG_250MS); 
    7832:	8c e0       	ldi	r24, 0x0C	; 12
    7834:	be d0       	rcall	.+380    	; 0x79b2 <watchdogConfig>
  }
//#endif

    
  // Adaboot no-wait mod, part 2
  if (!(ch & _BV(EXTRF))) appStart();
    7836:	01 ff       	sbrs	r16, 1
    7838:	d3 d0       	rcall	.+422    	; 0x79e0 <appStart>
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UCSR0A = _BV(U2X0); //Double speed mode USART0
    783a:	82 e0       	ldi	r24, 0x02	; 2
    783c:	80 93 c0 00 	sts	0x00C0, r24
  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    7840:	88 e1       	ldi	r24, 0x18	; 24
    7842:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
    7846:	86 e0       	ldi	r24, 0x06	; 6
    7848:	80 93 c2 00 	sts	0x00C2, r24
  UBRR0L = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
    784c:	89 e1       	ldi	r24, 0x19	; 25
    784e:	80 93 c4 00 	sts	0x00C4, r24
#endif
#endif

  // Set up watchdog to trigger after 500ms
  //watchdogConfig(WATCHDOG_OFF); // FJA DEBUG: turn off watchdog so we do not reset
  watchdogConfig(WATCHDOG_1S); // ORIGINAL CODE (BEFORE FJA)
    7852:	8e e0       	ldi	r24, 0x0E	; 14
    7854:	ae d0       	rcall	.+348    	; 0x79b2 <watchdogConfig>
    7856:	cc 24       	eor	r12, r12
    7858:	dd 24       	eor	r13, r13


  /* Forever loop */
  for (;;) {
    /* get character from UART */
    ch = getch();
    785a:	9f d0       	rcall	.+318    	; 0x799a <getch>

    if(ch == STK_GET_PARAMETER) {
    785c:	81 34       	cpi	r24, 0x41	; 65
    785e:	61 f4       	brne	.+24     	; 0x7878 <main+0x78>
      unsigned char which = getch();
    7860:	9c d0       	rcall	.+312    	; 0x799a <getch>
    7862:	08 2f       	mov	r16, r24
      verifySpace();
    7864:	ac d0       	rcall	.+344    	; 0x79be <verifySpace>
      if (which == 0x82) {
    7866:	02 38       	cpi	r16, 0x82	; 130
    7868:	11 f0       	breq	.+4      	; 0x786e <main+0x6e>
	/*
	 * Send optiboot version as "minor SW version"
	 */
	putch(OPTIBOOT_MINVER);
      } else if (which == 0x81) {
    786a:	01 38       	cpi	r16, 0x81	; 129
    786c:	11 f4       	brne	.+4      	; 0x7872 <main+0x72>
	  putch(OPTIBOOT_MAJVER);
    786e:	84 e0       	ldi	r24, 0x04	; 4
    7870:	01 c0       	rjmp	.+2      	; 0x7874 <main+0x74>
      } else {
	/*
	 * GET PARAMETER returns a generic 0x03 reply for
         * other parameters - enough to keep Avrdude happy
	 */
	putch(0x03);
    7872:	83 e0       	ldi	r24, 0x03	; 3
    7874:	8a d0       	rcall	.+276    	; 0x798a <putch>
    7876:	56 c0       	rjmp	.+172    	; 0x7924 <main+0x124>
      }
    }
    else if(ch == STK_SET_DEVICE) {
    7878:	82 34       	cpi	r24, 0x42	; 66
    787a:	11 f4       	brne	.+4      	; 0x7880 <main+0x80>
      // SET DEVICE is ignored
      getNch(20);
    787c:	84 e1       	ldi	r24, 0x14	; 20
    787e:	03 c0       	rjmp	.+6      	; 0x7886 <main+0x86>
    }
    else if(ch == STK_SET_DEVICE_EXT) {
    7880:	85 34       	cpi	r24, 0x45	; 69
    7882:	19 f4       	brne	.+6      	; 0x788a <main+0x8a>
      // SET DEVICE EXT is ignored
      getNch(5);
    7884:	85 e0       	ldi	r24, 0x05	; 5
    7886:	a4 d0       	rcall	.+328    	; 0x79d0 <getNch>
    7888:	4d c0       	rjmp	.+154    	; 0x7924 <main+0x124>
    }
    else if(ch == STK_LOAD_ADDRESS) {
    788a:	85 35       	cpi	r24, 0x55	; 85
    788c:	79 f4       	brne	.+30     	; 0x78ac <main+0xac>
      // LOAD ADDRESS
      uint16_t newAddress;
      newAddress = getch();
    788e:	85 d0       	rcall	.+266    	; 0x799a <getch>
      newAddress = (newAddress & 0xff) | (getch() << 8);
    7890:	e8 2e       	mov	r14, r24
    7892:	ff 24       	eor	r15, r15
    7894:	82 d0       	rcall	.+260    	; 0x799a <getch>
    7896:	08 2f       	mov	r16, r24
    7898:	10 e0       	ldi	r17, 0x00	; 0
    789a:	10 2f       	mov	r17, r16
    789c:	00 27       	eor	r16, r16
    789e:	0e 29       	or	r16, r14
    78a0:	1f 29       	or	r17, r15
#ifdef RAMPZ
      // Transfer top bit to RAMPZ
      RAMPZ = (newAddress & 0x8000) ? 1 : 0;
#endif
      newAddress += newAddress; // Convert from word address to byte address
    78a2:	00 0f       	add	r16, r16
    78a4:	11 1f       	adc	r17, r17
      address = newAddress;
      verifySpace();
    78a6:	8b d0       	rcall	.+278    	; 0x79be <verifySpace>
    78a8:	68 01       	movw	r12, r16
    78aa:	3c c0       	rjmp	.+120    	; 0x7924 <main+0x124>
    }
    else if(ch == STK_UNIVERSAL) {
    78ac:	86 35       	cpi	r24, 0x56	; 86
    78ae:	21 f4       	brne	.+8      	; 0x78b8 <main+0xb8>
      // UNIVERSAL command is ignored
      getNch(4);
    78b0:	84 e0       	ldi	r24, 0x04	; 4
    78b2:	8e d0       	rcall	.+284    	; 0x79d0 <getNch>
      putch(0x00);
    78b4:	80 e0       	ldi	r24, 0x00	; 0
    78b6:	de cf       	rjmp	.-68     	; 0x7874 <main+0x74>
    }
    /* Write memory, length is big endian and is in bytes */
    else if(ch == STK_PROG_PAGE) {
    78b8:	84 36       	cpi	r24, 0x64	; 100
    78ba:	71 f4       	brne	.+28     	; 0x78d8 <main+0xd8>
      // PROGRAM PAGE - we support flash programming only, not EEPROM
      uint8_t *bufPtr;
      //uint16_t addrPtr;

      getch();			/* getlen() */
    78bc:	6e d0       	rcall	.+220    	; 0x799a <getch>
      length = getch();
    78be:	6d d0       	rcall	.+218    	; 0x799a <getch>
    78c0:	08 2f       	mov	r16, r24
      getch();
    78c2:	6b d0       	rcall	.+214    	; 0x799a <getch>
    78c4:	c0 e2       	ldi	r28, 0x20	; 32
    78c6:	d3 e0       	ldi	r29, 0x03	; 3

	  // the original optiboot code erases memory before reading in the contents. this is faster but takes up more memory so I've taken it out.

      // read in page contents
      bufPtr = pagebuffer;
      do *bufPtr++ = getch();
    78c8:	68 d0       	rcall	.+208    	; 0x799a <getch>
    78ca:	89 93       	st	Y+, r24
      while (--length);
    78cc:	01 50       	subi	r16, 0x01	; 1
    78ce:	e1 f7       	brne	.-8      	; 0x78c8 <main+0xc8>

      // Read command terminator, start reply
      verifySpace();
    78d0:	76 d0       	rcall	.+236    	; 0x79be <verifySpace>

	  // flash the chip
	  write_pagebuffer((uint16_t)(void*)address);
    78d2:	c6 01       	movw	r24, r12
    78d4:	88 d3       	rcall	.+1808   	; 0x7fe6 <write_pagebuffer>
    78d6:	26 c0       	rjmp	.+76     	; 0x7924 <main+0x124>
    }

    /* Read memory block mode, length is big endian.  */
    else if(ch == STK_READ_PAGE) {
    78d8:	84 37       	cpi	r24, 0x74	; 116
    78da:	b1 f4       	brne	.+44     	; 0x7908 <main+0x108>
      // READ PAGE - we only read flash
      getch();			/* getlen() */
    78dc:	5e d0       	rcall	.+188    	; 0x799a <getch>
      length = getch();
    78de:	5d d0       	rcall	.+186    	; 0x799a <getch>
    78e0:	f8 2e       	mov	r15, r24
      getch();
    78e2:	5b d0       	rcall	.+182    	; 0x799a <getch>

      verifySpace();
    78e4:	6c d0       	rcall	.+216    	; 0x79be <verifySpace>
    78e6:	f6 01       	movw	r30, r12
    78e8:	ef 2c       	mov	r14, r15
        putch(result);
        address++;
      }
      while (--length);
#else
      do putch(pgm_read_byte_near(address++));
    78ea:	8f 01       	movw	r16, r30
    78ec:	0f 5f       	subi	r16, 0xFF	; 255
    78ee:	1f 4f       	sbci	r17, 0xFF	; 255
    78f0:	84 91       	lpm	r24, Z+
    78f2:	4b d0       	rcall	.+150    	; 0x798a <putch>
      while (--length);
    78f4:	ea 94       	dec	r14
    78f6:	f8 01       	movw	r30, r16
    78f8:	c1 f7       	brne	.-16     	; 0x78ea <main+0xea>

}


/* main program starts here */
int main(void) {
    78fa:	08 94       	sec
    78fc:	c1 1c       	adc	r12, r1
    78fe:	d1 1c       	adc	r13, r1
    7900:	fa 94       	dec	r15
    7902:	cf 0c       	add	r12, r15
    7904:	d1 1c       	adc	r13, r1
    7906:	0e c0       	rjmp	.+28     	; 0x7924 <main+0x124>
#endif
#endif
    }

    /* Get device signature bytes  */
    else if(ch == STK_READ_SIGN) {
    7908:	85 37       	cpi	r24, 0x75	; 117
    790a:	39 f4       	brne	.+14     	; 0x791a <main+0x11a>
      // READ SIGN - return what Avrdude wants to hear
      verifySpace();
    790c:	58 d0       	rcall	.+176    	; 0x79be <verifySpace>
      putch(SIGNATURE_0);
    790e:	8e e1       	ldi	r24, 0x1E	; 30
    7910:	3c d0       	rcall	.+120    	; 0x798a <putch>
      putch(SIGNATURE_1);
    7912:	85 e9       	ldi	r24, 0x95	; 149
    7914:	3a d0       	rcall	.+116    	; 0x798a <putch>
      putch(SIGNATURE_2);
    7916:	8f e0       	ldi	r24, 0x0F	; 15
    7918:	ad cf       	rjmp	.-166    	; 0x7874 <main+0x74>
    }
    else if (ch == 'Q') {
    791a:	81 35       	cpi	r24, 0x51	; 81
    791c:	11 f4       	brne	.+4      	; 0x7922 <main+0x122>
      // Adaboot no-wait mod
      watchdogConfig(WATCHDOG_16MS);
    791e:	88 e0       	ldi	r24, 0x08	; 8
    7920:	48 d0       	rcall	.+144    	; 0x79b2 <watchdogConfig>
      verifySpace();
    }
    else {
    
      // This covers the response to commands like STK_ENTER_PROGMODE
      verifySpace();
    7922:	4d d0       	rcall	.+154    	; 0x79be <verifySpace>
    }

    putch(STK_OK);
    7924:	80 e1       	ldi	r24, 0x10	; 16
    7926:	31 d0       	rcall	.+98     	; 0x798a <putch>
    7928:	98 cf       	rjmp	.-208    	; 0x785a <main+0x5a>

0000792a <greenLedON>:
#define wdtVect (*(uint16_t*)(RAMSTART+SPM_PAGESIZE*2+6))
#endif

// FJA: LED VERTE ON
void greenLedON() {
    DDRC |= (1 <<PC3);
    792a:	3b 9a       	sbi	0x07, 3	; 7
    PORTC |= (1 <<PC3);
    792c:	43 9a       	sbi	0x08, 3	; 8
   // mydelay(250000); // for debouncing

}
    792e:	08 95       	ret

00007930 <mydelay>:

    putch(STK_OK);
  }
}

void mydelay(unsigned long delay) {
    7930:	df 93       	push	r29
    7932:	cf 93       	push	r28
    7934:	00 d0       	rcall	.+0      	; 0x7936 <mydelay+0x6>
    7936:	00 d0       	rcall	.+0      	; 0x7938 <mydelay+0x8>
    7938:	cd b7       	in	r28, 0x3d	; 61
    793a:	de b7       	in	r29, 0x3e	; 62
    793c:	9b 01       	movw	r18, r22
    793e:	ac 01       	movw	r20, r24
  // added by Jonne Valola 2014
  volatile unsigned long i = 0;
    7940:	19 82       	std	Y+1, r1	; 0x01
    7942:	1a 82       	std	Y+2, r1	; 0x02
    7944:	1b 82       	std	Y+3, r1	; 0x03
    7946:	1c 82       	std	Y+4, r1	; 0x04
  for (i = 0; i < delay; i++) {
    7948:	19 82       	std	Y+1, r1	; 0x01
    794a:	1a 82       	std	Y+2, r1	; 0x02
    794c:	1b 82       	std	Y+3, r1	; 0x03
    794e:	1c 82       	std	Y+4, r1	; 0x04
    7950:	0c c0       	rjmp	.+24     	; 0x796a <mydelay+0x3a>
      __asm__ __volatile__ ("nop");
    7952:	00 00       	nop
}

void mydelay(unsigned long delay) {
  // added by Jonne Valola 2014
  volatile unsigned long i = 0;
  for (i = 0; i < delay; i++) {
    7954:	89 81       	ldd	r24, Y+1	; 0x01
    7956:	9a 81       	ldd	r25, Y+2	; 0x02
    7958:	ab 81       	ldd	r26, Y+3	; 0x03
    795a:	bc 81       	ldd	r27, Y+4	; 0x04
    795c:	01 96       	adiw	r24, 0x01	; 1
    795e:	a1 1d       	adc	r26, r1
    7960:	b1 1d       	adc	r27, r1
    7962:	89 83       	std	Y+1, r24	; 0x01
    7964:	9a 83       	std	Y+2, r25	; 0x02
    7966:	ab 83       	std	Y+3, r26	; 0x03
    7968:	bc 83       	std	Y+4, r27	; 0x04
    796a:	89 81       	ldd	r24, Y+1	; 0x01
    796c:	9a 81       	ldd	r25, Y+2	; 0x02
    796e:	ab 81       	ldd	r26, Y+3	; 0x03
    7970:	bc 81       	ldd	r27, Y+4	; 0x04
    7972:	82 17       	cp	r24, r18
    7974:	93 07       	cpc	r25, r19
    7976:	a4 07       	cpc	r26, r20
    7978:	b5 07       	cpc	r27, r21
    797a:	58 f3       	brcs	.-42     	; 0x7952 <mydelay+0x22>
      __asm__ __volatile__ ("nop");
  }
}
    797c:	0f 90       	pop	r0
    797e:	0f 90       	pop	r0
    7980:	0f 90       	pop	r0
    7982:	0f 90       	pop	r0
    7984:	cf 91       	pop	r28
    7986:	df 91       	pop	r29
    7988:	08 95       	ret

0000798a <putch>:

void putch(char ch) {
    798a:	98 2f       	mov	r25, r24
#ifndef SOFT_UART
  while (!(UCSR0A & _BV(UDRE0)));
    798c:	80 91 c0 00 	lds	r24, 0x00C0
    7990:	85 ff       	sbrs	r24, 5
    7992:	fc cf       	rjmp	.-8      	; 0x798c <putch+0x2>
  UDR0 = ch;
    7994:	90 93 c6 00 	sts	0x00C6, r25
      [uartBit] "I" (UART_TX_BIT)
    :
      "r25"
  );
#endif
}
    7998:	08 95       	ret

0000799a <getch>:
      [uartBit] "I" (UART_RX_BIT)
    :
      "r25"
);
#else
  while(!(UCSR0A & _BV(RXC0)))
    799a:	80 91 c0 00 	lds	r24, 0x00C0
    799e:	87 ff       	sbrs	r24, 7
    79a0:	fc cf       	rjmp	.-8      	; 0x799a <getch>
    ;
  if (!(UCSR0A & _BV(FE0))) {
    79a2:	80 91 c0 00 	lds	r24, 0x00C0
    79a6:	84 fd       	sbrc	r24, 4
    79a8:	01 c0       	rjmp	.+2      	; 0x79ac <getch+0x12>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    79aa:	a8 95       	wdr
       * don't care that an invalid char is returned...)
       */
    watchdogReset();
  }
  
  ch = UDR0;
    79ac:	80 91 c6 00 	lds	r24, 0x00C6
  //DEBUG FJA   LED_PIN |= _BV(LED);
#endif
#endif

  return ch;
}
    79b0:	08 95       	ret

000079b2 <watchdogConfig>:
    "wdr\n"
  );
}

void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
    79b2:	e0 e6       	ldi	r30, 0x60	; 96
    79b4:	f0 e0       	ldi	r31, 0x00	; 0
    79b6:	98 e1       	ldi	r25, 0x18	; 24
    79b8:	90 83       	st	Z, r25
  WDTCSR = x;
    79ba:	80 83       	st	Z, r24
}
    79bc:	08 95       	ret

000079be <verifySpace>:
  do getch(); while (--count);
  verifySpace();
}

void verifySpace() {
  if (getch() != CRC_EOP) {
    79be:	ed df       	rcall	.-38     	; 0x799a <getch>
    79c0:	80 32       	cpi	r24, 0x20	; 32
    79c2:	21 f0       	breq	.+8      	; 0x79cc <verifySpace+0xe>
  );
}

void reboot()
{
	watchdogConfig(WATCHDOG_16MS);
    79c4:	88 e0       	ldi	r24, 0x08	; 8
    79c6:	f5 df       	rcall	.-22     	; 0x79b2 <watchdogConfig>
	asm("sei");
    79c8:	78 94       	sei
    79ca:	ff cf       	rjmp	.-2      	; 0x79ca <verifySpace+0xc>

void verifySpace() {
  if (getch() != CRC_EOP) {
    reboot();
  }
  putch(STK_INSYNC);
    79cc:	84 e1       	ldi	r24, 0x14	; 20
}
    79ce:	dd cf       	rjmp	.-70     	; 0x798a <putch>

000079d0 <getNch>:
    ::[count] "M" (UART_B_VALUE)
  );
}
#endif

void getNch(uint8_t count) {
    79d0:	1f 93       	push	r17
    79d2:	18 2f       	mov	r17, r24
  do getch(); while (--count);
    79d4:	e2 df       	rcall	.-60     	; 0x799a <getch>
    79d6:	11 50       	subi	r17, 0x01	; 1
    79d8:	e9 f7       	brne	.-6      	; 0x79d4 <getNch+0x4>
  verifySpace();
    79da:	f1 df       	rcall	.-30     	; 0x79be <verifySpace>
}
    79dc:	1f 91       	pop	r17
    79de:	08 95       	ret

000079e0 <appStart>:
  WDTCSR = _BV(WDCE) | _BV(WDE);
  WDTCSR = x;
}

void appStart() {
  watchdogConfig(WATCHDOG_OFF);
    79e0:	80 e0       	ldi	r24, 0x00	; 0
    79e2:	e7 df       	rcall	.-50     	; 0x79b2 <watchdogConfig>
  
  __asm__ __volatile__ (
    79e4:	ee 27       	eor	r30, r30
    79e6:	ff 27       	eor	r31, r31
    79e8:	09 94       	ijmp

000079ea <load_game>:

// loads a game and reboots
void load_game(const char * filename)
{
	// don't want any interrupts corrupting our memory
	asm("cli");
    79ea:	f8 94       	cli
	asm volatile ("clr __zero_reg__");
    79ec:	11 24       	eor	r1, r1

	// if we're being called by the application then the filename could be anywhere in SRAM.
	// push it to the stack so that we don't accidentally overwrite it
	memcpy(FILENAME_LOCATION, filename, 9);
    79ee:	a7 ef       	ldi	r26, 0xF7	; 247
    79f0:	b8 e0       	ldi	r27, 0x08	; 8
    79f2:	fc 01       	movw	r30, r24
    79f4:	89 e0       	ldi	r24, 0x09	; 9
    79f6:	01 90       	ld	r0, Z+
    79f8:	0d 92       	st	X+, r0
    79fa:	81 50       	subi	r24, 0x01	; 1
    79fc:	e1 f7       	brne	.-8      	; 0x79f6 <load_game+0xc>

	// reset the stack back to the top of ram, not including space for the filename.
	SP=RAMEND-9;
    79fe:	86 ef       	ldi	r24, 0xF6	; 246
    7a00:	98 e0       	ldi	r25, 0x08	; 8
    7a02:	9e bf       	out	0x3e, r25	; 62
    7a04:	8d bf       	out	0x3d, r24	; 61

	load_file();
    7a06:	21 d1       	rcall	.+578    	; 0x7c4a <load_file>
  );
}

void reboot()
{
	watchdogConfig(WATCHDOG_16MS);
    7a08:	88 e0       	ldi	r24, 0x08	; 8
    7a0a:	d3 df       	rcall	.-90     	; 0x79b2 <watchdogConfig>
	asm("sei");
    7a0c:	78 94       	sei
    7a0e:	ff cf       	rjmp	.-2      	; 0x7a0e <load_game+0x24>

00007a10 <load_loader>:

#include <avr/pgmspace.h>

void load_loader()
{
	watchdogConfig(WATCHDOG_OFF);
    7a10:	80 e0       	ldi	r24, 0x00	; 0
    7a12:	cf df       	rcall	.-98     	; 0x79b2 <watchdogConfig>

	// silly, but it works
	static char filename[3];
	filename[0] = 'C';
    7a14:	83 e4       	ldi	r24, 0x43	; 67
    7a16:	80 93 00 01 	sts	0x0100, r24
	filename[1] = 'F';
    7a1a:	86 e4       	ldi	r24, 0x46	; 70
    7a1c:	80 93 01 01 	sts	0x0101, r24
	filename[2] = 'G';
    7a20:	87 e4       	ldi	r24, 0x47	; 71
    7a22:	80 93 02 01 	sts	0x0102, r24
    filename[3] = 0;
    7a26:	10 92 03 01 	sts	0x0103, r1
	load_game(filename);
    7a2a:	80 e0       	ldi	r24, 0x00	; 0
    7a2c:	91 e0       	ldi	r25, 0x01	; 1
}
    7a2e:	dd cf       	rjmp	.-70     	; 0x79ea <load_game>

00007a30 <spi_send_byte>:

/* ---[ SPI Interface ]---------------------------------------------- */

static void spi_send_byte(unsigned char data)
{
	SPDR=data;
    7a30:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF); // wait for byte transmitted...
    7a32:	0d b4       	in	r0, 0x2d	; 45
    7a34:	07 fe       	sbrs	r0, 7
    7a36:	fd cf       	rjmp	.-6      	; 0x7a32 <spi_send_byte+0x2>
}
    7a38:	08 95       	ret

00007a3a <send_cmd>:

static unsigned char send_cmd(void)
{
    7a3a:	1f 93       	push	r17
    7a3c:	cf 93       	push	r28
    7a3e:	df 93       	push	r29
	unsigned char i;
	unsigned char *buf;
	
	spi_send_byte(0xFF);      //Dummy delay 8 clocks
    7a40:	8f ef       	ldi	r24, 0xFF	; 255
    7a42:	f6 df       	rcall	.-20     	; 0x7a30 <spi_send_byte>
	MMC_PORT &= ~(1<<MMC_CS); //MMC Chip Select -> Low (activate mmc)
    7a44:	41 98       	cbi	0x08, 1	; 8
    7a46:	c3 e0       	ldi	r28, 0x03	; 3
    7a48:	d1 e0       	ldi	r29, 0x01	; 1

	/* send the 6 cmd bytes */
	i=6;
	buf = cmd;
	while(i) {
		spi_send_byte(*buf++);
    7a4a:	89 91       	ld	r24, Y+
    7a4c:	f1 df       	rcall	.-30     	; 0x7a30 <spi_send_byte>
	MMC_PORT &= ~(1<<MMC_CS); //MMC Chip Select -> Low (activate mmc)

	/* send the 6 cmd bytes */
	i=6;
	buf = cmd;
	while(i) {
    7a4e:	81 e0       	ldi	r24, 0x01	; 1
    7a50:	c9 30       	cpi	r28, 0x09	; 9
    7a52:	d8 07       	cpc	r29, r24
    7a54:	d1 f7       	brne	.-12     	; 0x7a4a <send_cmd+0x10>
    7a56:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char result;
	
	/* wait for response */
	for(i=0; i<255; i++) {
	
 		spi_send_byte(0xFF);
    7a58:	8f ef       	ldi	r24, 0xFF	; 255
    7a5a:	ea df       	rcall	.-44     	; 0x7a30 <spi_send_byte>
		result = SPDR;
    7a5c:	8e b5       	in	r24, 0x2e	; 46
		
		if ((result & 0x80) == 0)
    7a5e:	87 ff       	sbrs	r24, 7
    7a60:	03 c0       	rjmp	.+6      	; 0x7a68 <send_cmd+0x2e>
	}

	unsigned char result;
	
	/* wait for response */
	for(i=0; i<255; i++) {
    7a62:	1f 5f       	subi	r17, 0xFF	; 255
    7a64:	1f 3f       	cpi	r17, 0xFF	; 255
    7a66:	c1 f7       	brne	.-16     	; 0x7a58 <send_cmd+0x1e>
		if ((result & 0x80) == 0)
			break;
	}

	return(result); // TimeOut !?
}
    7a68:	df 91       	pop	r29
    7a6a:	cf 91       	pop	r28
    7a6c:	1f 91       	pop	r17
    7a6e:	08 95       	ret

00007a70 <mmc_start_read_block>:
 *			MMC_OK:						Command successful
 *			MMC_CMDERROR:			Error while sending read command to mmc
 *			MMC_NOSTARTBYTE:	No start byte received
 */
static unsigned char mmc_start_read_block(unsigned long adr)
{
    7a70:	1f 93       	push	r17
    7a72:	cf 93       	push	r28
    7a74:	df 93       	push	r29
	adr <<= 1;
    7a76:	66 0f       	add	r22, r22
    7a78:	77 1f       	adc	r23, r23
    7a7a:	88 1f       	adc	r24, r24
    7a7c:	99 1f       	adc	r25, r25
	
	cmd[0] = 0x40 + MMC_READ_SINGLE_BLOCK;
    7a7e:	21 e5       	ldi	r18, 0x51	; 81
    7a80:	20 93 03 01 	sts	0x0103, r18
	cmd[1] = (adr & 0x00FF0000) >> 0x10;
    7a84:	80 93 04 01 	sts	0x0104, r24
	cmd[2] = (adr & 0x0000FF00) >> 0x08;
    7a88:	70 93 05 01 	sts	0x0105, r23
	cmd[3] = (adr & 0x000000FF);
    7a8c:	60 93 06 01 	sts	0x0106, r22
	cmd[4] = 0;
    7a90:	10 92 07 01 	sts	0x0107, r1
	
	// There is something odd about how this behaves, so I'll disable it - Jonne
	// testing proves theory correct
	//SPCR = 1<<SPE | 1<<MSTR | SPI_READ_CLOCK; //SPI Enable, SPI Master Mode
	
	if (send_cmd() != 0x00 || wait_start_byte()) {
    7a94:	d2 df       	rcall	.-92     	; 0x7a3a <send_cmd>
    7a96:	88 23       	and	r24, r24
    7a98:	41 f4       	brne	.+16     	; 0x7aaa <mmc_start_read_block+0x3a>
    7a9a:	1f ef       	ldi	r17, 0xFF	; 255
{
	unsigned char i;
	
	i=255;
	do {
		spi_send_byte(0xFF);
    7a9c:	8f ef       	ldi	r24, 0xFF	; 255
    7a9e:	c8 df       	rcall	.-112    	; 0x7a30 <spi_send_byte>
		if(SPDR == 0xFE) return MMC_OK;
    7aa0:	8e b5       	in	r24, 0x2e	; 46
    7aa2:	8e 3f       	cpi	r24, 0xFE	; 254
    7aa4:	29 f0       	breq	.+10     	; 0x7ab0 <mmc_start_read_block+0x40>
	} while(--i);
    7aa6:	11 50       	subi	r17, 0x01	; 1
    7aa8:	c9 f7       	brne	.-14     	; 0x7a9c <mmc_start_read_block+0x2c>
	// There is something odd about how this behaves, so I'll disable it - Jonne
	// testing proves theory correct
	//SPCR = 1<<SPE | 1<<MSTR | SPI_READ_CLOCK; //SPI Enable, SPI Master Mode
	
	if (send_cmd() != 0x00 || wait_start_byte()) {
		MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate mmc);
    7aaa:	41 9a       	sbi	0x08, 1	; 8
    7aac:	83 e0       	ldi	r24, 0x03	; 3
    7aae:	10 c0       	rjmp	.+32     	; 0x7ad0 <mmc_start_read_block+0x60>
		return(MMC_CMDERROR); //wrong response!
    7ab0:	ce e1       	ldi	r28, 0x1E	; 30
    7ab2:	d1 e0       	ldi	r29, 0x01	; 1
 
	buf = buff;
	len= 512;
	
	while (len) {
		spi_send_byte(0xFF);
    7ab4:	8f ef       	ldi	r24, 0xFF	; 255
    7ab6:	bc df       	rcall	.-136    	; 0x7a30 <spi_send_byte>
		*buf++ = SPDR;
    7ab8:	8e b5       	in	r24, 0x2e	; 46
    7aba:	89 93       	st	Y+, r24
	unsigned short len;
 
	buf = buff;
	len= 512;
	
	while (len) {
    7abc:	83 e0       	ldi	r24, 0x03	; 3
    7abe:	ce 31       	cpi	r28, 0x1E	; 30
    7ac0:	d8 07       	cpc	r29, r24
    7ac2:	c1 f7       	brne	.-16     	; 0x7ab4 <mmc_start_read_block+0x44>
		len--;
	}
	
	//mmc_stop_read_block
	//read 2 bytes CRC (not used);
	spi_send_byte(0xFF);
    7ac4:	8f ef       	ldi	r24, 0xFF	; 255
    7ac6:	b4 df       	rcall	.-152    	; 0x7a30 <spi_send_byte>
	spi_send_byte(0xFF);
    7ac8:	8f ef       	ldi	r24, 0xFF	; 255
    7aca:	b2 df       	rcall	.-156    	; 0x7a30 <spi_send_byte>
	MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate mmc);
    7acc:	41 9a       	sbi	0x08, 1	; 8
    7ace:	80 e0       	ldi	r24, 0x00	; 0
	return(MMC_OK);
}
    7ad0:	df 91       	pop	r29
    7ad2:	cf 91       	pop	r28
    7ad4:	1f 91       	pop	r17
    7ad6:	08 95       	ret

00007ad8 <file_read_byte>:
	file.sector_counter++;
}

/* ----[ file ]--------------------------------------------------- */

static uint8_t file_read_byte() {	// read a byte from the open file from the mmc...
    7ad8:	6f 92       	push	r6
    7ada:	7f 92       	push	r7
    7adc:	9f 92       	push	r9
    7ade:	af 92       	push	r10
    7ae0:	bf 92       	push	r11
    7ae2:	cf 92       	push	r12
    7ae4:	df 92       	push	r13
    7ae6:	ef 92       	push	r14
    7ae8:	ff 92       	push	r15
    7aea:	0f 93       	push	r16
    7aec:	1f 93       	push	r17
    7aee:	cf 93       	push	r28
    7af0:	df 93       	push	r29
	if (file.next >= buff + 512) {
    7af2:	a0 90 1c 01 	lds	r10, 0x011C
    7af6:	b0 90 1d 01 	lds	r11, 0x011D
    7afa:	8e e1       	ldi	r24, 0x1E	; 30
    7afc:	a8 16       	cp	r10, r24
    7afe:	83 e0       	ldi	r24, 0x03	; 3
    7b00:	b8 06       	cpc	r11, r24
    7b02:	08 f4       	brcc	.+2      	; 0x7b06 <file_read_byte+0x2e>
    7b04:	61 c0       	rjmp	.+194    	; 0x7bc8 <file_read_byte+0xf0>
{
	uint16_t clusteroffset;
	uint8_t currentfatsector;
	uint8_t temp, secoffset;
	uint32_t templong;
	uint16_t cluster = file.startcluster;
    7b06:	c0 91 14 01 	lds	r28, 0x0114
    7b0a:	d0 91 15 01 	lds	r29, 0x0115
	
	fatsector_t *fatsector = (fatsector_t*) buff;

	/* SectorsPerCluster is always power of 2 ! */
	secoffset = (uint8_t)file.sector_counter & (SectorsPerCluster-1);
    7b0e:	c0 90 16 01 	lds	r12, 0x0116
    7b12:	d0 90 17 01 	lds	r13, 0x0117
    7b16:	e0 90 11 01 	lds	r14, 0x0111
	
	clusteroffset = file.sector_counter;
	temp = SectorsPerCluster >> 1;
    7b1a:	9e 2c       	mov	r9, r14
    7b1c:	96 94       	lsr	r9
    7b1e:	89 2d       	mov	r24, r9
    7b20:	86 01       	movw	r16, r12
    7b22:	03 c0       	rjmp	.+6      	; 0x7b2a <file_read_byte+0x52>
	while(temp) {
		clusteroffset >>= 1;
    7b24:	16 95       	lsr	r17
    7b26:	07 95       	ror	r16
        temp >>= 1;
    7b28:	86 95       	lsr	r24
	/* SectorsPerCluster is always power of 2 ! */
	secoffset = (uint8_t)file.sector_counter & (SectorsPerCluster-1);
	
	clusteroffset = file.sector_counter;
	temp = SectorsPerCluster >> 1;
	while(temp) {
    7b2a:	88 23       	and	r24, r24
    7b2c:	d9 f7       	brne	.-10     	; 0x7b24 <file_read_byte+0x4c>
	{
		temp = (unsigned char)((cluster & 0xFF00) >>8);
          
		if (currentfatsector != temp)
		{
			mmc_start_read_block(FATRegionStartSec + temp);
    7b2e:	60 90 12 01 	lds	r6, 0x0112
    7b32:	70 90 13 01 	lds	r7, 0x0113
    7b36:	2f ef       	ldi	r18, 0xFF	; 255
    7b38:	16 c0       	rjmp	.+44     	; 0x7b66 <file_read_byte+0x8e>
    }

	currentfatsector = 0xFF;
	while (clusteroffset)
	{
		temp = (unsigned char)((cluster & 0xFF00) >>8);
    7b3a:	8d 2f       	mov	r24, r29
    7b3c:	99 27       	eor	r25, r25
    7b3e:	f8 2e       	mov	r15, r24
          
		if (currentfatsector != temp)
    7b40:	28 17       	cp	r18, r24
    7b42:	31 f0       	breq	.+12     	; 0x7b50 <file_read_byte+0x78>
		{
			mmc_start_read_block(FATRegionStartSec + temp);
    7b44:	b3 01       	movw	r22, r6
    7b46:	68 0f       	add	r22, r24
    7b48:	71 1d       	adc	r23, r1
    7b4a:	80 e0       	ldi	r24, 0x00	; 0
    7b4c:	90 e0       	ldi	r25, 0x00	; 0
    7b4e:	90 df       	rcall	.-224    	; 0x7a70 <mmc_start_read_block>

			currentfatsector = temp;
		}
		
		cluster = fatsector->fat_entry[cluster % 256];
    7b50:	fe 01       	movw	r30, r28
    7b52:	f0 70       	andi	r31, 0x00	; 0
    7b54:	ee 0f       	add	r30, r30
    7b56:	ff 1f       	adc	r31, r31
    7b58:	e2 5e       	subi	r30, 0xE2	; 226
    7b5a:	fe 4f       	sbci	r31, 0xFE	; 254
    7b5c:	c0 81       	ld	r28, Z
    7b5e:	d1 81       	ldd	r29, Z+1	; 0x01
		clusteroffset--;
    7b60:	01 50       	subi	r16, 0x01	; 1
    7b62:	10 40       	sbci	r17, 0x00	; 0
    7b64:	2f 2d       	mov	r18, r15
		clusteroffset >>= 1;
        temp >>= 1;
    }

	currentfatsector = 0xFF;
	while (clusteroffset)
    7b66:	01 15       	cp	r16, r1
    7b68:	11 05       	cpc	r17, r1
    7b6a:	39 f7       	brne	.-50     	; 0x7b3a <file_read_byte+0x62>
		
		cluster = fatsector->fat_entry[cluster % 256];
		clusteroffset--;
	}

	templong = cluster - 2;
    7b6c:	22 97       	sbiw	r28, 0x02	; 2
    7b6e:	9e 01       	movw	r18, r28
    7b70:	40 e0       	ldi	r20, 0x00	; 0
    7b72:	50 e0       	ldi	r21, 0x00	; 0
    7b74:	05 c0       	rjmp	.+10     	; 0x7b80 <file_read_byte+0xa8>
	temp = SectorsPerCluster>>1;
	while(temp) {
		templong <<= 1;	
    7b76:	22 0f       	add	r18, r18
    7b78:	33 1f       	adc	r19, r19
    7b7a:	44 1f       	adc	r20, r20
    7b7c:	55 1f       	adc	r21, r21
		temp >>= 1;
    7b7e:	96 94       	lsr	r9
		clusteroffset--;
	}

	templong = cluster - 2;
	temp = SectorsPerCluster>>1;
	while(temp) {
    7b80:	99 20       	and	r9, r9
    7b82:	c9 f7       	brne	.-14     	; 0x7b76 <file_read_byte+0x9e>
		templong <<= 1;	
		temp >>= 1;
	}
		
	/* read the sector of the file into the buffer */
	mmc_start_read_block(templong + DataRegionStartSec + secoffset);
    7b84:	ea 94       	dec	r14
    7b86:	ec 20       	and	r14, r12
    7b88:	60 91 0b 01 	lds	r22, 0x010B
    7b8c:	70 91 0c 01 	lds	r23, 0x010C
    7b90:	80 91 0d 01 	lds	r24, 0x010D
    7b94:	90 91 0e 01 	lds	r25, 0x010E
    7b98:	6e 0d       	add	r22, r14
    7b9a:	71 1d       	adc	r23, r1
    7b9c:	81 1d       	adc	r24, r1
    7b9e:	91 1d       	adc	r25, r1
    7ba0:	62 0f       	add	r22, r18
    7ba2:	73 1f       	adc	r23, r19
    7ba4:	84 1f       	adc	r24, r20
    7ba6:	95 1f       	adc	r25, r21
    7ba8:	63 df       	rcall	.-314    	; 0x7a70 <mmc_start_read_block>
	
	/* advance to next sector */
	file.sector_counter++;
    7baa:	08 94       	sec
    7bac:	c1 1c       	adc	r12, r1
    7bae:	d1 1c       	adc	r13, r1
    7bb0:	d0 92 17 01 	sts	0x0117, r13
    7bb4:	c0 92 16 01 	sts	0x0116, r12
/* ----[ file ]--------------------------------------------------- */

static uint8_t file_read_byte() {	// read a byte from the open file from the mmc...
	if (file.next >= buff + 512) {
	    fat16_readfilesector();
		file.next = file.next - 512;
    7bb8:	80 e0       	ldi	r24, 0x00	; 0
    7bba:	9e ef       	ldi	r25, 0xFE	; 254
    7bbc:	a8 0e       	add	r10, r24
    7bbe:	b9 1e       	adc	r11, r25
    7bc0:	b0 92 1d 01 	sts	0x011D, r11
    7bc4:	a0 92 1c 01 	sts	0x011C, r10
	}
	file.size--;
    7bc8:	80 91 18 01 	lds	r24, 0x0118
    7bcc:	90 91 19 01 	lds	r25, 0x0119
    7bd0:	a0 91 1a 01 	lds	r26, 0x011A
    7bd4:	b0 91 1b 01 	lds	r27, 0x011B
    7bd8:	01 97       	sbiw	r24, 0x01	; 1
    7bda:	a1 09       	sbc	r26, r1
    7bdc:	b1 09       	sbc	r27, r1
    7bde:	80 93 18 01 	sts	0x0118, r24
    7be2:	90 93 19 01 	sts	0x0119, r25
    7be6:	a0 93 1a 01 	sts	0x011A, r26
    7bea:	b0 93 1b 01 	sts	0x011B, r27
	return *file.next++;
    7bee:	e0 91 1c 01 	lds	r30, 0x011C
    7bf2:	f0 91 1d 01 	lds	r31, 0x011D
    7bf6:	81 91       	ld	r24, Z+
    7bf8:	f0 93 1d 01 	sts	0x011D, r31
    7bfc:	e0 93 1c 01 	sts	0x011C, r30
}
    7c00:	df 91       	pop	r29
    7c02:	cf 91       	pop	r28
    7c04:	1f 91       	pop	r17
    7c06:	0f 91       	pop	r16
    7c08:	ff 90       	pop	r15
    7c0a:	ef 90       	pop	r14
    7c0c:	df 90       	pop	r13
    7c0e:	cf 90       	pop	r12
    7c10:	bf 90       	pop	r11
    7c12:	af 90       	pop	r10
    7c14:	9f 90       	pop	r9
    7c16:	7f 90       	pop	r7
    7c18:	6f 90       	pop	r6
    7c1a:	08 95       	ret

00007c1c <gethexnib>:

static char gethexnib(char a) {
	if(a >= 'a') {
    7c1c:	81 36       	cpi	r24, 0x61	; 97
    7c1e:	14 f0       	brlt	.+4      	; 0x7c24 <gethexnib+0x8>
		return (a - 'a' + 0x0a);
    7c20:	87 55       	subi	r24, 0x57	; 87
    7c22:	08 95       	ret
	} else if(a >= 'A') {
    7c24:	81 34       	cpi	r24, 0x41	; 65
    7c26:	14 f0       	brlt	.+4      	; 0x7c2c <gethexnib+0x10>
		return (a - 'A' + 0x0a);
    7c28:	87 53       	subi	r24, 0x37	; 55
    7c2a:	08 95       	ret
	} else if(a >= '0') {
    7c2c:	80 33       	cpi	r24, 0x30	; 48
    7c2e:	0c f0       	brlt	.+2      	; 0x7c32 <gethexnib+0x16>
		return(a - '0');
    7c30:	80 53       	subi	r24, 0x30	; 48
	}
	return a;
}
    7c32:	08 95       	ret

00007c34 <file_read_hex>:

static uint8_t file_read_hex(void) {
    7c34:	1f 93       	push	r17
	return (gethexnib(file_read_byte()) << 4) + gethexnib(file_read_byte());
    7c36:	50 df       	rcall	.-352    	; 0x7ad8 <file_read_byte>
    7c38:	f1 df       	rcall	.-30     	; 0x7c1c <gethexnib>
    7c3a:	18 2f       	mov	r17, r24
    7c3c:	4d df       	rcall	.-358    	; 0x7ad8 <file_read_byte>
    7c3e:	ee df       	rcall	.-36     	; 0x7c1c <gethexnib>
    7c40:	12 95       	swap	r17
    7c42:	10 7f       	andi	r17, 0xF0	; 240
}
    7c44:	81 0f       	add	r24, r17
    7c46:	1f 91       	pop	r17
    7c48:	08 95       	ret

00007c4a <load_file>:
		}
	}
	if (out != pagebuffer) write_pagebuffer(address);
}

int load_file() {
    7c4a:	4f 92       	push	r4
    7c4c:	5f 92       	push	r5
    7c4e:	6f 92       	push	r6
    7c50:	7f 92       	push	r7
    7c52:	8f 92       	push	r8
    7c54:	9f 92       	push	r9
    7c56:	af 92       	push	r10
    7c58:	bf 92       	push	r11
    7c5a:	cf 92       	push	r12
    7c5c:	df 92       	push	r13
    7c5e:	ef 92       	push	r14
    7c60:	ff 92       	push	r15
    7c62:	0f 93       	push	r16
    7c64:	1f 93       	push	r17
    7c66:	cf 93       	push	r28
    7c68:	df 93       	push	r29
*/
static inline unsigned char mmc_init(void)
{
	// the default after reset is already input
	//SPI_DDR &= ~(1<<SPI_MISO);	//SPI Data Out -> Input
	SPI_PORT |= 1<<SPI_SS;   //PB2 output: High (deselect other SPI chips)
    7c6a:	2a 9a       	sbi	0x05, 2	; 5

	SPI_DDR  |= 1<<SPI_CLK | 1<<SPI_MOSI | 1<<SPI_SS; // SPI Data -> Output
    7c6c:	84 b1       	in	r24, 0x04	; 4
    7c6e:	8c 62       	ori	r24, 0x2C	; 44
    7c70:	84 b9       	out	0x04, r24	; 4
	MMC_DDR |= 1<<MMC_CS; 	//MMC Chip Select -> Output
    7c72:	39 9a       	sbi	0x07, 1	; 7
	
	// Enable SPI, Master, clock rate f_osc/128
	SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);
    7c74:	83 e5       	ldi	r24, 0x53	; 83
    7c76:	8c bd       	out	0x2c, r24	; 44
	// clear double speed
	SPSR &= ~(1 << SPI2X);
    7c78:	8d b5       	in	r24, 0x2d	; 45
    7c7a:	8e 7f       	andi	r24, 0xFE	; 254
    7c7c:	8d bd       	out	0x2d, r24	; 45
    7c7e:	0a e0       	ldi	r16, 0x0A	; 10
	
	unsigned char i;
	
	i=10;
	while(i) { //Pulse 80+ clocks to reset MMC
		spi_send_byte(0xFF);	
    7c80:	8f ef       	ldi	r24, 0xFF	; 255
    7c82:	d6 de       	rcall	.-596    	; 0x7a30 <spi_send_byte>
 		i--;
    7c84:	01 50       	subi	r16, 0x01	; 1
	SPSR &= ~(1 << SPI2X);
	
	unsigned char i;
	
	i=10;
	while(i) { //Pulse 80+ clocks to reset MMC
    7c86:	e1 f7       	brne	.-8      	; 0x7c80 <load_file+0x36>
 		i--;
	}

	unsigned char res;

	cmd[0] = 0x40 + MMC_GO_IDLE_STATE;
    7c88:	80 e4       	ldi	r24, 0x40	; 64
    7c8a:	80 93 03 01 	sts	0x0103, r24
	cmd[1] = 0x00; cmd[2] = 0x00; cmd[3] = 0x00; cmd[4] = 0x00; cmd[5] = 0x95;
    7c8e:	10 92 04 01 	sts	0x0104, r1
    7c92:	10 92 05 01 	sts	0x0105, r1
    7c96:	10 92 06 01 	sts	0x0106, r1
    7c9a:	10 92 07 01 	sts	0x0107, r1
    7c9e:	85 e9       	ldi	r24, 0x95	; 149
    7ca0:	80 93 08 01 	sts	0x0108, r24
	
	for (i=0; i<MMC_CMD0_RETRY; i++)
	{
		res=send_cmd(); //store result of reset command, should be 0x01
    7ca4:	ca de       	rcall	.-620    	; 0x7a3a <send_cmd>
    7ca6:	18 2f       	mov	r17, r24

		MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate mmc);
    7ca8:	41 9a       	sbi	0x08, 1	; 8
      	 	spi_send_byte(0xFF);
    7caa:	8f ef       	ldi	r24, 0xFF	; 255
    7cac:	c1 de       	rcall	.-638    	; 0x7a30 <spi_send_byte>
		if (res == 0x01)
    7cae:	11 30       	cpi	r17, 0x01	; 1
    7cb0:	09 f4       	brne	.+2      	; 0x7cb4 <load_file+0x6a>
    7cb2:	67 c1       	rjmp	.+718    	; 0x7f82 <load_file+0x338>
	unsigned char res;

	cmd[0] = 0x40 + MMC_GO_IDLE_STATE;
	cmd[1] = 0x00; cmd[2] = 0x00; cmd[3] = 0x00; cmd[4] = 0x00; cmd[5] = 0x95;
	
	for (i=0; i<MMC_CMD0_RETRY; i++)
    7cb4:	0f 5f       	subi	r16, 0xFF	; 255
    7cb6:	00 31       	cpi	r16, 0x10	; 16
    7cb8:	a9 f7       	brne	.-22     	; 0x7ca4 <load_file+0x5a>
    7cba:	29 c1       	rjmp	.+594    	; 0x7f0e <load_file+0x2c4>
		
//May be this becomes an endless loop ?
//Counting i from 0 to 255 and then timeout
//was to SHORT for some of my cards !
	while(send_cmd() != 0) {
		MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate);
    7cbc:	41 9a       	sbi	0x08, 1	; 8
		spi_send_byte(0xFF);
    7cbe:	8f ef       	ldi	r24, 0xFF	; 255
    7cc0:	b7 de       	rcall	.-658    	; 0x7a30 <spi_send_byte>
	cmd[0]=0x40 + MMC_SEND_OP_COND;
		
//May be this becomes an endless loop ?
//Counting i from 0 to 255 and then timeout
//was to SHORT for some of my cards !
	while(send_cmd() != 0) {
    7cc2:	bb de       	rcall	.-650    	; 0x7a3a <send_cmd>
    7cc4:	88 23       	and	r24, r24
    7cc6:	d1 f7       	brne	.-12     	; 0x7cbc <load_file+0x72>
    7cc8:	35 c1       	rjmp	.+618    	; 0x7f34 <load_file+0x2ea>
			return 1;
	
    mmc_start_read_block(0);

    // Try sector 0 as a bootsector
	if ((vbr->bsFileSysType[0] == 'F') && (vbr->bsFileSysType[4] == '6'))
    7cca:	80 91 58 01 	lds	r24, 0x0158
    7cce:	86 33       	cpi	r24, 0x36	; 54
    7cd0:	29 f4       	brne	.+10     	; 0x7cdc <load_file+0x92>
	{
		FATRegionStartSec = 0;
    7cd2:	10 92 13 01 	sts	0x0113, r1
    7cd6:	10 92 12 01 	sts	0x0112, r1
    7cda:	17 c0       	rjmp	.+46     	; 0x7d0a <load_file+0xc0>
	}
	else // Try sector 0 as a MBR	
	{     	 
		FATRegionStartSec = mbr->sector.partition[0].sectorOffset;
    7cdc:	60 91 e4 02 	lds	r22, 0x02E4
    7ce0:	70 91 e5 02 	lds	r23, 0x02E5
    7ce4:	80 91 e6 02 	lds	r24, 0x02E6
    7ce8:	90 91 e7 02 	lds	r25, 0x02E7
    7cec:	70 93 13 01 	sts	0x0113, r23
    7cf0:	60 93 12 01 	sts	0x0112, r22
          
		mmc_start_read_block(mbr->sector.partition[0].sectorOffset);
    7cf4:	bd de       	rcall	.-646    	; 0x7a70 <mmc_start_read_block>
	  
        if ((vbr->bsFileSysType[0] != 'F') || (vbr->bsFileSysType[4] != '6'))
    7cf6:	80 91 54 01 	lds	r24, 0x0154
    7cfa:	86 34       	cpi	r24, 0x46	; 70
    7cfc:	09 f0       	breq	.+2      	; 0x7d00 <load_file+0xb6>
    7cfe:	07 c1       	rjmp	.+526    	; 0x7f0e <load_file+0x2c4>
    7d00:	80 91 58 01 	lds	r24, 0x0158
    7d04:	86 33       	cpi	r24, 0x36	; 54
    7d06:	09 f0       	breq	.+2      	; 0x7d0a <load_file+0xc0>
    7d08:	02 c1       	rjmp	.+516    	; 0x7f0e <load_file+0x2c4>
			return 2; // No FAT16 found
     }
    
	SectorsPerCluster  			= vbr->bsSecPerClus; // 4
    7d0a:	80 91 2b 01 	lds	r24, 0x012B
    7d0e:	80 93 11 01 	sts	0x0111, r24
	
	// Calculation Algorithms
	FATRegionStartSec			+= vbr->bsRsvdSecCnt;						// 6
    7d12:	40 91 2c 01 	lds	r20, 0x012C
    7d16:	50 91 2d 01 	lds	r21, 0x012D
    7d1a:	80 91 12 01 	lds	r24, 0x0112
    7d1e:	90 91 13 01 	lds	r25, 0x0113
    7d22:	48 0f       	add	r20, r24
    7d24:	59 1f       	adc	r21, r25
    7d26:	50 93 13 01 	sts	0x0113, r21
    7d2a:	40 93 12 01 	sts	0x0112, r20
	RootDirRegionStartSec	 	= FATRegionStartSec + (vbr->bsNumFATs * vbr->bsNrSeProFAT16);		// 496	
    7d2e:	80 91 2e 01 	lds	r24, 0x012E
    7d32:	90 e0       	ldi	r25, 0x00	; 0
    7d34:	20 91 34 01 	lds	r18, 0x0134
    7d38:	30 91 35 01 	lds	r19, 0x0135
    7d3c:	82 9f       	mul	r24, r18
    7d3e:	50 01       	movw	r10, r0
    7d40:	83 9f       	mul	r24, r19
    7d42:	b0 0c       	add	r11, r0
    7d44:	92 9f       	mul	r25, r18
    7d46:	b0 0c       	add	r11, r0
    7d48:	11 24       	eor	r1, r1
    7d4a:	a4 0e       	add	r10, r20
    7d4c:	b5 1e       	adc	r11, r21
    7d4e:	b0 92 0a 01 	sts	0x010A, r11
    7d52:	a0 92 09 01 	sts	0x0109, r10
	RootDirRegionSize		 	= (vbr->bsRootEntCnt / 16); 						// 32
    7d56:	c0 90 2f 01 	lds	r12, 0x012F
    7d5a:	d0 90 30 01 	lds	r13, 0x0130
    7d5e:	34 e0       	ldi	r19, 0x04	; 4
    7d60:	d6 94       	lsr	r13
    7d62:	c7 94       	ror	r12
    7d64:	3a 95       	dec	r19
    7d66:	e1 f7       	brne	.-8      	; 0x7d60 <load_file+0x116>
    7d68:	d0 92 10 01 	sts	0x0110, r13
    7d6c:	c0 92 0f 01 	sts	0x010F, r12
	DataRegionStartSec 			= RootDirRegionStartSec + RootDirRegionSize;	// 528
    7d70:	c5 01       	movw	r24, r10
    7d72:	8c 0d       	add	r24, r12
    7d74:	9d 1d       	adc	r25, r13
    7d76:	a0 e0       	ldi	r26, 0x00	; 0
    7d78:	b0 e0       	ldi	r27, 0x00	; 0
    7d7a:	80 93 0b 01 	sts	0x010B, r24
    7d7e:	90 93 0c 01 	sts	0x010C, r25
    7d82:	a0 93 0d 01 	sts	0x010D, r26
    7d86:	b0 93 0e 01 	sts	0x010E, r27
    7d8a:	80 90 1c 01 	lds	r8, 0x011C
    7d8e:	90 90 1d 01 	lds	r9, 0x011D
    7d92:	40 90 16 01 	lds	r4, 0x0116
    7d96:	50 90 17 01 	lds	r5, 0x0117
    7d9a:	e0 90 18 01 	lds	r14, 0x0118
    7d9e:	f0 90 19 01 	lds	r15, 0x0119
    7da2:	00 91 1a 01 	lds	r16, 0x011A
    7da6:	10 91 1b 01 	lds	r17, 0x011B
    7daa:	60 90 14 01 	lds	r6, 0x0114
    7dae:	70 90 15 01 	lds	r7, 0x0115
    7db2:	c0 e0       	ldi	r28, 0x00	; 0
    7db4:	d0 e0       	ldi	r29, 0x00	; 0
static inline uint8_t fat16_readRootDirEntry(uint16_t entry_num) {
	uint8_t direntry_in_sector;
 	direntry_t *dir;
		
	/* Check for end of root dir region reached! */
	if ((entry_num / 16) >= RootDirRegionSize)
    7db6:	be 01       	movw	r22, r28
    7db8:	24 e0       	ldi	r18, 0x04	; 4
    7dba:	76 95       	lsr	r23
    7dbc:	67 95       	ror	r22
    7dbe:	2a 95       	dec	r18
    7dc0:	e1 f7       	brne	.-8      	; 0x7dba <load_file+0x170>
    7dc2:	6c 15       	cp	r22, r12
    7dc4:	7d 05       	cpc	r23, r13
    7dc6:	f0 f5       	brcc	.+124    	; 0x7e44 <load_file+0x1fa>
	/* this is the offset inside the sector */
	/* there are 16 entries in a sector, each 32 bytes long */
    direntry_in_sector = (unsigned char) entry_num % 16;

	/* get the sector into the buffer */
	mmc_start_read_block(dirsector);
    7dc8:	6a 0d       	add	r22, r10
    7dca:	7b 1d       	adc	r23, r11
    7dcc:	80 e0       	ldi	r24, 0x00	; 0
    7dce:	90 e0       	ldi	r25, 0x00	; 0
    7dd0:	4f de       	rcall	.-866    	; 0x7a70 <mmc_start_read_block>
	
	/* pointer to the direntry inside the buffer */
	dir = (direntry_t *) buff + direntry_in_sector;
    7dd2:	9e 01       	movw	r18, r28
    7dd4:	2f 70       	andi	r18, 0x0F	; 15
    7dd6:	a2 2f       	mov	r26, r18
    7dd8:	b0 e0       	ldi	r27, 0x00	; 0
    7dda:	95 e0       	ldi	r25, 0x05	; 5
    7ddc:	aa 0f       	add	r26, r26
    7dde:	bb 1f       	adc	r27, r27
    7de0:	9a 95       	dec	r25
    7de2:	e1 f7       	brne	.-8      	; 0x7ddc <load_file+0x192>
    7de4:	a2 5e       	subi	r26, 0xE2	; 226
    7de6:	be 4f       	sbci	r27, 0xFE	; 254

	if ((dir->name[0] == 0) || (dir->name[0] == 0xE5) || (dir->fstclust == 0))
    7de8:	8c 91       	ld	r24, X
    7dea:	88 23       	and	r24, r24
    7dec:	59 f1       	breq	.+86     	; 0x7e44 <load_file+0x1fa>
    7dee:	5a 96       	adiw	r26, 0x1a	; 26
    7df0:	2d 91       	ld	r18, X+
    7df2:	3c 91       	ld	r19, X
    7df4:	5b 97       	sbiw	r26, 0x1b	; 27
    7df6:	21 15       	cp	r18, r1
    7df8:	31 05       	cpc	r19, r1
    7dfa:	21 f1       	breq	.+72     	; 0x7e44 <load_file+0x1fa>
		return 0;

	/* fill in the file structure */
	file.startcluster = dir->fstclust;
	file.size = dir->filesize;
    7dfc:	5c 96       	adiw	r26, 0x1c	; 28
    7dfe:	ed 90       	ld	r14, X+
    7e00:	fd 90       	ld	r15, X+
    7e02:	0d 91       	ld	r16, X+
    7e04:	1c 91       	ld	r17, X
    7e06:	5f 97       	sbiw	r26, 0x1f	; 31
	file.sector_counter = 0;
	file.next = buff + 512;
    7e08:	8e e1       	ldi	r24, 0x1E	; 30
    7e0a:	88 2e       	mov	r8, r24
    7e0c:	83 e0       	ldi	r24, 0x03	; 3
    7e0e:	98 2e       	mov	r9, r24
    7e10:	51 e0       	ldi	r21, 0x01	; 1
    7e12:	90 e0       	ldi	r25, 0x00	; 0
    7e14:	09 c0       	rjmp	.+18     	; 0x7e28 <load_file+0x1de>

	/* compare name */
	uint8_t i = 0;
	uint8_t match = 1;
	for (i = 0; FILENAME_LOCATION[i]; i++) { 
	  match &= (FILENAME_LOCATION[i] == dir->name[i]);
    7e16:	40 e0       	ldi	r20, 0x00	; 0
    7e18:	ea 0f       	add	r30, r26
    7e1a:	fb 1f       	adc	r31, r27
    7e1c:	80 81       	ld	r24, Z
    7e1e:	68 17       	cp	r22, r24
    7e20:	09 f4       	brne	.+2      	; 0x7e24 <load_file+0x1da>
    7e22:	41 e0       	ldi	r20, 0x01	; 1
    7e24:	54 23       	and	r21, r20
	file.next = buff + 512;

	/* compare name */
	uint8_t i = 0;
	uint8_t match = 1;
	for (i = 0; FILENAME_LOCATION[i]; i++) { 
    7e26:	9f 5f       	subi	r25, 0xFF	; 255
    7e28:	e9 2f       	mov	r30, r25
    7e2a:	f0 e0       	ldi	r31, 0x00	; 0
    7e2c:	e9 50       	subi	r30, 0x09	; 9
    7e2e:	f7 4f       	sbci	r31, 0xF7	; 247
    7e30:	60 81       	ld	r22, Z
    7e32:	e7 5f       	subi	r30, 0xF7	; 247
    7e34:	f8 40       	sbci	r31, 0x08	; 8
    7e36:	66 23       	and	r22, r22
    7e38:	71 f7       	brne	.-36     	; 0x7e16 <load_file+0x1cc>
	  match &= (FILENAME_LOCATION[i] == dir->name[i]);
	}
	if (!(match && i)) return 0; else return 1;
    7e3a:	55 23       	and	r21, r21
    7e3c:	29 f0       	breq	.+10     	; 0x7e48 <load_file+0x1fe>
    7e3e:	99 23       	and	r25, r25
    7e40:	19 f0       	breq	.+6      	; 0x7e48 <load_file+0x1fe>
    7e42:	83 c0       	rjmp	.+262    	; 0x7f4a <load_file+0x300>
    7e44:	93 01       	movw	r18, r6
    7e46:	02 c0       	rjmp	.+4      	; 0x7e4c <load_file+0x202>
    7e48:	44 24       	eor	r4, r4
    7e4a:	55 24       	eor	r5, r5
	/* first, init mmc / fat */
	if (fat16_init() != 0)
		return 2;
    
	/* for each file in ROOT... */
	for (entrycounter=0; entrycounter<512; entrycounter++)
    7e4c:	21 96       	adiw	r28, 0x01	; 1
    7e4e:	82 e0       	ldi	r24, 0x02	; 2
    7e50:	c0 30       	cpi	r28, 0x00	; 0
    7e52:	d8 07       	cpc	r29, r24
    7e54:	11 f0       	breq	.+4      	; 0x7e5a <load_file+0x210>
    7e56:	39 01       	movw	r6, r18
    7e58:	ae cf       	rjmp	.-164    	; 0x7db6 <load_file+0x16c>
    7e5a:	90 92 1d 01 	sts	0x011D, r9
    7e5e:	80 92 1c 01 	sts	0x011C, r8
    7e62:	50 92 17 01 	sts	0x0117, r5
    7e66:	40 92 16 01 	sts	0x0116, r4
    7e6a:	e0 92 18 01 	sts	0x0118, r14
    7e6e:	f0 92 19 01 	sts	0x0119, r15
    7e72:	00 93 1a 01 	sts	0x011A, r16
    7e76:	10 93 1b 01 	sts	0x011B, r17
    7e7a:	30 93 15 01 	sts	0x0115, r19
    7e7e:	20 93 14 01 	sts	0x0114, r18
    7e82:	81 e0       	ldi	r24, 0x01	; 1
    7e84:	90 e0       	ldi	r25, 0x00	; 0
    7e86:	45 c0       	rjmp	.+138    	; 0x7f12 <load_file+0x2c8>
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    address = 0;
	while (file.size)
	{
		if (num_flash_words)
    7e88:	11 23       	and	r17, r17
    7e8a:	c9 f0       	breq	.+50     	; 0x7ebe <load_file+0x274>
		{
			// read (de-hexify)
			*out++ = file_read_hex();
    7e8c:	d3 de       	rcall	.-602    	; 0x7c34 <file_read_hex>
    7e8e:	89 93       	st	Y+, r24
			num_flash_words--;
    7e90:	11 50       	subi	r17, 0x01	; 1
		
			// if pagebuffer is full
			if (out - pagebuffer == SPM_PAGESIZE) {
    7e92:	23 e0       	ldi	r18, 0x03	; 3
    7e94:	c0 3a       	cpi	r28, 0xA0	; 160
    7e96:	d2 07       	cpc	r29, r18
    7e98:	19 f5       	brne	.+70     	; 0x7ee0 <load_file+0x296>
			    // write page
				write_pagebuffer(address);
    7e9a:	80 91 1e 03 	lds	r24, 0x031E
    7e9e:	90 91 1f 03 	lds	r25, 0x031F
    7ea2:	a1 d0       	rcall	.+322    	; 0x7fe6 <write_pagebuffer>
			    address += SPM_PAGESIZE;
    7ea4:	80 91 1e 03 	lds	r24, 0x031E
    7ea8:	90 91 1f 03 	lds	r25, 0x031F
    7eac:	80 58       	subi	r24, 0x80	; 128
    7eae:	9f 4f       	sbci	r25, 0xFF	; 255
    7eb0:	90 93 1f 03 	sts	0x031F, r25
    7eb4:	80 93 1e 03 	sts	0x031E, r24
    7eb8:	c0 e2       	ldi	r28, 0x20	; 32
    7eba:	d3 e0       	ldi	r29, 0x03	; 3
    7ebc:	11 c0       	rjmp	.+34     	; 0x7ee0 <load_file+0x296>
			}
		} 
		else
		{
			// skip bytes until we find another ':'
			if (file_read_byte() == ':') {
    7ebe:	0c de       	rcall	.-1000   	; 0x7ad8 <file_read_byte>
    7ec0:	8a 33       	cpi	r24, 0x3A	; 58
    7ec2:	71 f4       	brne	.+28     	; 0x7ee0 <load_file+0x296>
				num_flash_words = file_read_hex();
    7ec4:	b7 de       	rcall	.-658    	; 0x7c34 <file_read_hex>
    7ec6:	18 2f       	mov	r17, r24
				file.next+=4; /* skip 4 bytes */
    7ec8:	80 91 1c 01 	lds	r24, 0x011C
    7ecc:	90 91 1d 01 	lds	r25, 0x011D
    7ed0:	04 96       	adiw	r24, 0x04	; 4
    7ed2:	90 93 1d 01 	sts	0x011D, r25
    7ed6:	80 93 1c 01 	sts	0x011C, r24
				if (file_read_hex()) break;
    7eda:	ac de       	rcall	.-680    	; 0x7c34 <file_read_hex>
    7edc:	88 23       	and	r24, r24
    7ede:	61 f4       	brne	.+24     	; 0x7ef8 <load_file+0x2ae>
static inline void read_hex_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    address = 0;
	while (file.size)
    7ee0:	80 91 18 01 	lds	r24, 0x0118
    7ee4:	90 91 19 01 	lds	r25, 0x0119
    7ee8:	a0 91 1a 01 	lds	r26, 0x011A
    7eec:	b0 91 1b 01 	lds	r27, 0x011B
    7ef0:	00 97       	sbiw	r24, 0x00	; 0
    7ef2:	a1 05       	cpc	r26, r1
    7ef4:	b1 05       	cpc	r27, r1
    7ef6:	41 f6       	brne	.-112    	; 0x7e88 <load_file+0x23e>
				file.next+=4; /* skip 4 bytes */
				if (file_read_hex()) break;
			}
		}
	}
	if (out != pagebuffer) write_pagebuffer(address);
    7ef8:	c0 52       	subi	r28, 0x20	; 32
    7efa:	d3 40       	sbci	r29, 0x03	; 3
    7efc:	29 f0       	breq	.+10     	; 0x7f08 <load_file+0x2be>
    7efe:	80 91 1e 03 	lds	r24, 0x031E
    7f02:	90 91 1f 03 	lds	r25, 0x031F
    7f06:	6f d0       	rcall	.+222    	; 0x7fe6 <write_pagebuffer>
    7f08:	80 e0       	ldi	r24, 0x00	; 0
    7f0a:	90 e0       	ldi	r25, 0x00	; 0
    7f0c:	02 c0       	rjmp	.+4      	; 0x7f12 <load_file+0x2c8>
    7f0e:	82 e0       	ldi	r24, 0x02	; 2
    7f10:	90 e0       	ldi	r25, 0x00	; 0
			return 0; // no error
		}
	}	
	
	return 1; // file not found
}
    7f12:	df 91       	pop	r29
    7f14:	cf 91       	pop	r28
    7f16:	1f 91       	pop	r17
    7f18:	0f 91       	pop	r16
    7f1a:	ff 90       	pop	r15
    7f1c:	ef 90       	pop	r14
    7f1e:	df 90       	pop	r13
    7f20:	cf 90       	pop	r12
    7f22:	bf 90       	pop	r11
    7f24:	af 90       	pop	r10
    7f26:	9f 90       	pop	r9
    7f28:	8f 90       	pop	r8
    7f2a:	7f 90       	pop	r7
    7f2c:	6f 90       	pop	r6
    7f2e:	5f 90       	pop	r5
    7f30:	4f 90       	pop	r4
    7f32:	08 95       	ret
	vbr_t *vbr = (vbr_t*) buff;
		
	if (mmc_init() != MMC_OK)
			return 1;
	
    mmc_start_read_block(0);
    7f34:	60 e0       	ldi	r22, 0x00	; 0
    7f36:	70 e0       	ldi	r23, 0x00	; 0
    7f38:	80 e0       	ldi	r24, 0x00	; 0
    7f3a:	90 e0       	ldi	r25, 0x00	; 0
    7f3c:	99 dd       	rcall	.-1230   	; 0x7a70 <mmc_start_read_block>

    // Try sector 0 as a bootsector
	if ((vbr->bsFileSysType[0] == 'F') && (vbr->bsFileSysType[4] == '6'))
    7f3e:	80 91 54 01 	lds	r24, 0x0154
    7f42:	86 34       	cpi	r24, 0x46	; 70
    7f44:	09 f0       	breq	.+2      	; 0x7f48 <load_file+0x2fe>
    7f46:	ca ce       	rjmp	.-620    	; 0x7cdc <load_file+0x92>
    7f48:	c0 ce       	rjmp	.-640    	; 0x7cca <load_file+0x80>
    7f4a:	90 92 1d 01 	sts	0x011D, r9
    7f4e:	80 92 1c 01 	sts	0x011C, r8
    7f52:	10 92 17 01 	sts	0x0117, r1
    7f56:	10 92 16 01 	sts	0x0116, r1
    7f5a:	e0 92 18 01 	sts	0x0118, r14
    7f5e:	f0 92 19 01 	sts	0x0119, r15
    7f62:	00 93 1a 01 	sts	0x011A, r16
    7f66:	10 93 1b 01 	sts	0x011B, r17
    7f6a:	30 93 15 01 	sts	0x0115, r19
    7f6e:	20 93 14 01 	sts	0x0114, r18

static inline void read_hex_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    address = 0;
    7f72:	10 92 1f 03 	sts	0x031F, r1
    7f76:	10 92 1e 03 	sts	0x031E, r1
    7f7a:	c0 e2       	ldi	r28, 0x20	; 32
    7f7c:	d3 e0       	ldi	r29, 0x03	; 3
    7f7e:	10 e0       	ldi	r17, 0x00	; 0
    7f80:	af cf       	rjmp	.-162    	; 0x7ee0 <load_file+0x296>
	if(i==MMC_CMD0_RETRY) return(MMC_TIMEOUT);

	if (res != 0x01) //Response R1 from MMC (0x01: IDLE, The card is in idle state and running the initializing process.)
		return(MMC_INIT);
	
	cmd[0]=0x40 + MMC_SEND_OP_COND;
    7f82:	81 e4       	ldi	r24, 0x41	; 65
    7f84:	80 93 03 01 	sts	0x0103, r24
    7f88:	9c ce       	rjmp	.-712    	; 0x7cc2 <load_file+0x78>

00007f8a <write_flash_page>:
uint16_t address;

/* access to flash memory------------------------------------------ */

void write_flash_page(uint16_t addr, uint8_t * data)
{
    7f8a:	1f 93       	push	r17
    7f8c:	ac 01       	movw	r20, r24
	uint16_t i = 0;

	eeprom_busy_wait();
    7f8e:	f9 99       	sbic	0x1f, 1	; 31
    7f90:	fe cf       	rjmp	.-4      	; 0x7f8e <write_flash_page+0x4>

	//__boot_page_erase_short(addr);
	__boot_page_erase_normal(addr); // try to improve stability of flash - JV2014
    7f92:	83 e0       	ldi	r24, 0x03	; 3
    7f94:	fa 01       	movw	r30, r20
    7f96:	80 93 57 00 	sts	0x0057, r24
    7f9a:	e8 95       	spm
	boot_spm_busy_wait ();      // Wait until the memory is erased.
    7f9c:	07 b6       	in	r0, 0x37	; 55
    7f9e:	00 fc       	sbrc	r0, 0
    7fa0:	fd cf       	rjmp	.-6      	; 0x7f9c <write_flash_page+0x12>
    7fa2:	20 e0       	ldi	r18, 0x00	; 0
    7fa4:	30 e0       	ldi	r19, 0x00	; 0
	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		// Set up little-endian word.
		uint16_t w = *((uint16_t*)(data + i));
		//__boot_page_fill_short(addr + i, w); // try to improve stability of flash - JV2014
		__boot_page_fill_normal(addr + i, w);
    7fa6:	11 e0       	ldi	r17, 0x01	; 1
    7fa8:	f9 01       	movw	r30, r18
    7faa:	e4 0f       	add	r30, r20
    7fac:	f5 1f       	adc	r31, r21
    7fae:	db 01       	movw	r26, r22
    7fb0:	a2 0f       	add	r26, r18
    7fb2:	b3 1f       	adc	r27, r19
    7fb4:	8d 91       	ld	r24, X+
    7fb6:	9c 91       	ld	r25, X
    7fb8:	0c 01       	movw	r0, r24
    7fba:	10 93 57 00 	sts	0x0057, r17
    7fbe:	e8 95       	spm
    7fc0:	11 24       	eor	r1, r1

	//__boot_page_erase_short(addr);
	__boot_page_erase_normal(addr); // try to improve stability of flash - JV2014
	boot_spm_busy_wait ();      // Wait until the memory is erased.

	for (i=0; i<SPM_PAGESIZE; i+=2)
    7fc2:	2e 5f       	subi	r18, 0xFE	; 254
    7fc4:	3f 4f       	sbci	r19, 0xFF	; 255
    7fc6:	20 38       	cpi	r18, 0x80	; 128
    7fc8:	31 05       	cpc	r19, r1
    7fca:	71 f7       	brne	.-36     	; 0x7fa8 <write_flash_page+0x1e>
		//__boot_page_fill_short(addr + i, w); // try to improve stability of flash - JV2014
		__boot_page_fill_normal(addr + i, w);
	}

	//__boot_page_write_short(addr);     // Store buffer in flash page.
	__boot_page_write_normal(addr);     // try to improve stability of flash - JV2014
    7fcc:	85 e0       	ldi	r24, 0x05	; 5
    7fce:	fa 01       	movw	r30, r20
    7fd0:	80 93 57 00 	sts	0x0057, r24
    7fd4:	e8 95       	spm
	boot_spm_busy_wait();            // Wait until the memory is written.
    7fd6:	07 b6       	in	r0, 0x37	; 55
    7fd8:	00 fc       	sbrc	r0, 0
    7fda:	fd cf       	rjmp	.-6      	; 0x7fd6 <write_flash_page+0x4c>

	boot_rww_enable ();
    7fdc:	81 e1       	ldi	r24, 0x11	; 17
    7fde:	87 bf       	out	0x37, r24	; 55
    7fe0:	e8 95       	spm
}
    7fe2:	1f 91       	pop	r17
    7fe4:	08 95       	ret

00007fe6 <write_pagebuffer>:

void write_pagebuffer(uint16_t addr)
{
	// don't overwrite the last page, it's reserved for user settings
	if (addr <= 0x7800-2*SPM_PAGESIZE)
    7fe6:	27 e7       	ldi	r18, 0x77	; 119
    7fe8:	81 30       	cpi	r24, 0x01	; 1
    7fea:	92 07       	cpc	r25, r18
    7fec:	18 f4       	brcc	.+6      	; 0x7ff4 <write_pagebuffer+0xe>
		write_flash_page(addr, pagebuffer);
    7fee:	60 e2       	ldi	r22, 0x20	; 32
    7ff0:	73 e0       	ldi	r23, 0x03	; 3
    7ff2:	cb cf       	rjmp	.-106    	; 0x7f8a <write_flash_page>
    7ff4:	08 95       	ret

Disassembly of section .jumps:

00007ffa <_jumptable>:
    7ffa:	c7 cf       	rjmp	.-114    	; 0x7f8a <write_flash_page>
    7ffc:	f6 cc       	rjmp	.-1556   	; 0x79ea <load_game>
